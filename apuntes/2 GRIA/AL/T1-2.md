# Introducci√≥n, b√∫squedas y programaci√≥n din·∏øica
## Algoritmos | 2¬∫GRIA

Un **algoritmo** es un conjunto finito y ordenado de pasos o instrucciones precisas que permiten resolver un problema o realizar una tarea, es decir, llegar a su resultado o soluci√≥n. 
Los algoritmos son las bases de los programas, ya que no dejan de ser un algoritmo en leguaje m√°quina. No obstante, los algoritmos existieron ya desde antes de la inform√°tica. Por ejemplo:
* Babilonia: Existian algoritmos de resoluci√≥n de ecuaciones y problemas matem√°ticos
* Euclides: Desarrollo un algoritmo mara calcular el MCD. El mas antiguo y documentado


Con respecto a las computadoras, los algoritmos son secuencias formalizadas y precisas que una computadora puede entender
y ejecutar. Todos los programas estan construidos sobre ellos y se traducen en lenguajes de programaci√≥n para su ejecucion. Se caracterizan por ser claros, eficientes (Resoluci√≥n en tiempo razonable y pocos recursos) y ser generales (Vale para una familia de problemas). Hay varios tipos de algoritmos:
* B√∫squeda: Encontrar informaci√≥n en una base de datos o en la web
* Ordenamiento: Organizar datos
* Criptogr√°Ô¨Åcos: Proteger informaci√≥n
* Inteligencia artiÔ¨Åcial: Reconocer im√°genes, traducir textos o recomendar canciones

En este caso nos vamos a centrar en los de **b√∫squeda**.

La b√∫squeda es un proceso de encontrar un elemento ovjetivo dentro de un grupo de elementos o determinar su inexistencia. El objetivo para su optimizaci√≥n es minimizar el numero de comparaciones lo m√°ximo pos√≠ble. Las busquedas pueden ser internas (Memoria principal) y Externa (Memoria secundaria). Hay varios tipos de b√∫squeda:


### B√∫squeda lineal
El tipo mas sencillo, compara uno a uno los elementos hasta encontrar el necesario o revisar sin √©xito. Complejidad O(n).
Ejemplo: Busco 5 en [1, 4, 5, 6, 7, 9]
- Entro en primer elemento ¬ø1 = 5? No. Seguimos
- Entro en el segundo ¬ø4 = 6? No, seguimos.
- Entro en el tercero ¬ø5 = 5? ¬°Si! Encontrado

```java
public static int bus_lineal(int[] valores, int buscar) {
    for (int i = 0; i < valores.length; i++) {
        if (valores[i] == buscar) {
            return i; // ¬°Encontrado!
        }
    }
    return -1; // No encontrado
}

// Ejemplo de uso:

int[] datos = {5, 12, 7, 9, 3};
int posicion = bus_lineal(datos, 9);
System.out.println("Resultado de la b√∫squeda: " + posicion);
```

## B√∫squeda binaria
Deben de estar ordenados los elementos. Disminuye progresivamente el n¬∫ de elementos sobre el que se realiza la busqueda a la mitad. TRas log2n divisiones se locaiza el elemento o se sabe que no est√°. Complejidad O(log n).
Ejemplo: Busco 1 en [1, 4, 5, 7, 9]
- Voy a la mitad. ¬ø5 > 1? Si, mantengo izquierda.
- Tengo 4 ¬ø4 > 1? Si, mantengo izquierda
- ¬ø1 <= 1? ¬ø1 = 1? Si ¬°Encontrado!

```java

public static int bus_binaria(int[] valores, int buscar) {
    int izq = 0, dcha = valores.length - 1;
    while (izq <= dcha) {
        int med = (izq + dcha) / 2;
        if (valores[med] == buscar) return med;
        if (valores[med] < buscar) izq = med + 1;
        else dcha = med - 1;
    }
    return -1; // No encontrado
}

//Si encuentra el valor, imprime la posici√≥n:
System.out.println(bus_binaria(new int[]{1, 3, 5, 7, 9, 11}, 7)); 
```

## B√∫squeda mediante hashing
Es un tipo de b√∫squeda que emplea funciones hash, tranforma un elemento en una direcci√≥n o √≠ndice situado dentro del array. 

Una funci√≥n hash es una regla matem√°tica que transforma una entrada en un valor, que suelen ser n√∫meros enteros. Esta entrada puede ser un texto, otro n√∫mero... 

Una clave es el objeto que empleas para acceder a un valor. Por ejemplo en 'map.put("58966854I", "Anxo")' la clave ser√≠a 58966854I.

El valor obtenido al transformar la clave se denomina HashCode, se calcula usando el m√©todo 'hashCode ()' y reflejar√° la posicion del elemento dentro de una **tabla hash** (La estructura donde se almacenan estos elementos). Si dos elementos tienen el mismo HashCode se produce una **colisi√≥n**.

La posici√≥n de la tabla hash donde se guarda el par clave-valor se llama bucket. Para ver en que bucket cae una clave, el HashCode se transforma en un √≠ndice y se sigue esta formula: 'int bucketIndex = hash & (capacity - 1)'. El razonamiento que emplea la formula es el siguiente:
* Obtengo la clave 65954 y la capacidad de mi sistema es 16 (El m√≠nimo en HashMaps)
* Transformo la clave y capacidad a binario, obteniendo 1000 0000 0110 0010 y 00001111 respectivamente
* Como la capacidad tiene 4 bits, me quedo con los √∫ltimos 4 bits de la clave (0010)
* Lo transformo a decimal y obtengo que cae en el bucket 2

Las ventajas de este sistema es que los elementos no tienen por que estar ordenados y que es independiente al n√∫mero de elementos. En la mayor parte de los casos se emplea la clave como el √≠ndice de cada registro. La eficiencia del m√©todo depende de como de uniforme distrubuye nuestra funci√≥n hash los elementos.

Ejemplo:

```java
import java.util.HashMap;

public class HashSearchExample2 {
    public static void main(String[] args) {
        HashMap<Integer, String> estudiantes = new HashMap<>();
        estudiantes.put(101, "Ana");
        estudiantes.put(202, "Luis");
        estudiantes.put(303, "Mar√≠a");

        // Buscar
        int id = 202;
        if (estudiantes.containsKey(id)) {
            System.out.println("Alumno encontrado: " + estudiantes.get(id));
        } else {
            System.out.println("Alumno no registrado");
        }
    }
}
```

Para evitar colisiones, se emplean t√©cnicas como truncamiento (Uso los X √∫ltimos d√≠gitos de la clave como √≠ndice), Divisi√≥n (Siendo m el tama√±o de la tabla y k la clave, calculo $‚Ñé(ùëò) = ùëò mod ùëö $. Por ejemplo: Clave 21 tama√±o 10 ser√≠a 1) o mediante potencias (Se eleva la clave a un n√∫mero y se utilizan n√∫meros del medio. Por ejemplo $589¬≤ = 346921  \Longrightarrow 469 $ si cogemos los 3 n√∫meros del medio).




# Programaci√≥n Din√°mica
T√©cnica de dise√±o de algoritmos utilizada para resolver problemas que pueden dividirse en subproblemas m√°s peque√±os que se repiten. Tiene como objetivo reducir el tiempo de ejecuci√≥n evitando recalcular soluciones previas. La programaci√≥n din√°mica almacena los resultados mediante un proceso denominado ‚Äúmemorizaci√≥n‚Äù o ‚Äúalmacenamiento en tabla‚Äù, a diferencia de los algoritmos recursivos cl√°sicos. Este proceso es √∫til pero se debe equilibrar la optimizaci√≥n de tiempo y espacio seg√∫n las necesidades del problema, ya que en el caso contrario se puede demasiado almacenamiento. La PD solo funciona cuando el problema completo puede construirse a partir de las soluciones √≥ptimas de sus subproblemas, lo que se denomina subestructura √≥ptima. Hay varios tipos de dise√±o:
* Top-down que usa recursi√≥n para resolver los subproblemas cuando los necesita y guarda sus soluciones en una estructura como diccionarios o arrays
* Bottom-up que empieza por los subproblemas m√°s peque√±os y sigue hasta llegar al problema completo (En general m√°s eficiente)

## Recursividad

Un m√©todo recursivo es aquel que se resuelve llam√°ndose a s√≠ mismo con una versi√≥n m√°s simple del problema.
Para que funcione:
* Se define un caso base, cuya soluci√≥n es inmediata y no necesita m√°s llamadas.
* Cada llamada reduce la complejidad del problema, acerc√°ndose al caso base.
* Al alcanzarlo, la soluci√≥n se devuelve hacia atr√°s, resolviendo las llamadas pendientes hasta llegar a la inicial.
La recursi√≥n es √∫til cuando un problema puede expresarse en t√©rminos de s√≠ mismo y suele ofrecer soluciones m√°s claras y elegantes.

Ejemplo:

```java
public static int factorial(int n) {
    if (n == 1) {
        return 1; 
    }
    return n * factorial(n - 1);
}
```
